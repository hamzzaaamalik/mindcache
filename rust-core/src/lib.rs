//! MindCache - A lightweight, local-first memory engine for AI applications

pub mod storage;
pub mod session;
pub mod decay;

use std::collections::HashMap;
use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use chrono::Utc; // Remove unused DateTime import
use serde::{Deserialize, Serialize};
use serde_json;

// Re-export main types for easier usage
pub use storage::{MemoryStorage, MemoryItem, QueryFilter};
pub use session::{SessionManager, Session, SessionSummary};
pub use decay::{MemoryDecayEngine, DecayPolicy, DecayStats};

/// Main MindCache client that orchestrates all memory operations
pub struct MindCache {
    storage: MemoryStorage,
    session_manager: SessionManager,
    decay_engine: MemoryDecayEngine,
    config: MindCacheConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MindCacheConfig {
    pub storage_path: String,
    pub auto_decay_enabled: bool,
    pub decay_interval_hours: u32,
    pub default_memory_ttl_hours: Option<u32>,
    pub enable_compression: bool,
    pub max_memories_per_user: usize,
    pub importance_threshold: f32,
}

impl Default for MindCacheConfig {
    fn default() -> Self {
        MindCacheConfig {
            storage_path: "./mindcache_data".to_string(),
            auto_decay_enabled: true,
            decay_interval_hours: 24,
            default_memory_ttl_hours: Some(24 * 30), // 30 days
            enable_compression: true,
            max_memories_per_user: 10000,
            importance_threshold: 0.3,
        }
    }
}

impl MindCache {
    /// Create a new MindCache instance with default configuration
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        Self::with_config(MindCacheConfig::default())
    }

    /// Create a new MindCache instance with custom configuration
    pub fn with_config(config: MindCacheConfig) -> Result<Self, Box<dyn std::error::Error>> {
        let storage = MemoryStorage::new(&config.storage_path)?;
        let session_manager = SessionManager::new(storage.clone());
        
        let decay_policy = DecayPolicy {
            max_age_hours: config.default_memory_ttl_hours.unwrap_or(24 * 30),
            importance_threshold: config.importance_threshold,
            max_memories_per_user: config.max_memories_per_user,
            compression_enabled: config.enable_compression,
            auto_summarize_sessions: true,
        };

        // Fix: Clone the session_manager instead of moving it
        let decay_engine = MemoryDecayEngine::with_policy(
            storage.clone(),
            session_manager.clone(), // Fix: clone here
            decay_policy
        );

        Ok(MindCache {
            storage,
            session_manager,
            decay_engine,
            config,
        })
    }


    /// Save a memory item
    pub fn save(&mut self, user_id: &str, session_id: &str, content: &str, metadata: Option<HashMap<String, String>>) -> Result<String, Box<dyn std::error::Error>> {
        let memory = MemoryItem {
            id: String::new(), // Will be generated by storage
            user_id: user_id.to_string(),
            session_id: session_id.to_string(),
            content: content.to_string(),
            metadata: metadata.unwrap_or_default(),
            timestamp: Utc::now(),
            ttl_hours: self.config.default_memory_ttl_hours,
            importance: 0.5, // Default importance
        };

        self.storage.save(memory)
    }

    /// Save a memory item with custom importance and TTL
    pub fn save_with_options(&mut self, user_id: &str, session_id: &str, content: &str, 
                           metadata: Option<HashMap<String, String>>, importance: f32, ttl_hours: Option<u32>) -> Result<String, Box<dyn std::error::Error>> {
        let memory = MemoryItem {
            id: String::new(),
            user_id: user_id.to_string(),
            session_id: session_id.to_string(),
            content: content.to_string(),
            metadata: metadata.unwrap_or_default(),
            timestamp: Utc::now(),
            ttl_hours,
            importance: importance.clamp(0.0, 1.0),
        };

        self.storage.save(memory)
    }

    /// Recall memories with flexible filtering
    pub fn recall(&self, user_id: &str, query: Option<&str>, session_id: Option<&str>, limit: Option<usize>) -> Result<Vec<MemoryItem>, Box<dyn std::error::Error>> {
        let keywords = query.map(|q| {
            q.split_whitespace()
                .map(|s| s.to_string())
                .collect::<Vec<String>>()
        });

        let filter = QueryFilter {
            user_id: Some(user_id.to_string()),
            session_id: session_id.map(|s| s.to_string()),
            keywords,
            date_from: None,
            date_to: None,
            limit,
            min_importance: None,
        };

        self.storage.recall(filter)
    }

    /// Recall memories with advanced filtering
    pub fn recall_advanced(&self, filter: QueryFilter) -> Result<Vec<MemoryItem>, Box<dyn std::error::Error>> {
        self.storage.recall(filter)
    }

    /// Get memories for a specific session
    pub fn get_session_memories(&self, user_id: &str, session_id: &str) -> Result<Vec<MemoryItem>, Box<dyn std::error::Error>> {
        // Use the main storage instead of session manager's storage
        self.storage.get_session_memories(user_id, session_id)
    }
    /// Create a new session
    pub fn create_session(&mut self, user_id: &str, session_name: Option<&str>) -> Result<String, Box<dyn std::error::Error>> {
        self.session_manager.create_session(user_id, session_name.map(|s| s.to_string()))
    }

    /// Get all sessions for a user
    pub fn get_user_sessions(&mut self, user_id: &str) -> Result<Vec<Session>, Box<dyn std::error::Error>> {
        // Use the main storage to rebuild sessions
        self.session_manager.get_user_sessions(user_id)
    }

    /// Generate a summary for a session
    pub fn summarize_session(&mut self, session_id: &str) -> Result<SessionSummary, Box<dyn std::error::Error>> {
        self.session_manager.generate_session_summary(session_id)
    }

    /// Search sessions by content
    pub fn search_sessions(&mut self, user_id: &str, keywords: Vec<String>) -> Result<Vec<Session>, Box<dyn std::error::Error>> {
        self.session_manager.search_sessions(user_id, keywords)
    }

    /// Run memory decay process
    pub fn decay(&mut self) -> Result<DecayStats, Box<dyn std::error::Error>> {
        self.decay_engine.run_decay()
    }

    /// Get storage and decay statistics
    pub fn get_stats(&self) -> HashMap<String, serde_json::Value> {
        let mut stats = HashMap::new();
        
        // Storage stats
        let storage_stats = self.storage.get_stats();
        stats.insert("storage".to_string(), serde_json::to_value(storage_stats).unwrap());
        
        // Session stats
        let session_stats = self.session_manager.get_session_stats();
        stats.insert("sessions".to_string(), serde_json::to_value(session_stats).unwrap());
        
        // Decay stats
        let decay_stats = self.decay_engine.get_stats();
        stats.insert("decay".to_string(), serde_json::to_value(decay_stats).unwrap());
        
        stats
    }

    /// Export all memories for a user (for backup/migration)
    pub fn export_user_memories(&self, user_id: &str) -> Result<String, Box<dyn std::error::Error>> {
        let filter = QueryFilter {
            user_id: Some(user_id.to_string()),
            session_id: None,
            keywords: None,
            date_from: None,
            date_to: None,
            limit: None,
            min_importance: None,
        };

        let memories = self.storage.recall(filter)?;
        let export_data = serde_json::to_string_pretty(&memories)?;
        Ok(export_data)
    }

    /// Update configuration
    pub fn update_config(&mut self, config: MindCacheConfig) -> Result<(), Box<dyn std::error::Error>> {
        // Update decay policy based on new config
        let decay_policy = DecayPolicy {
            max_age_hours: config.default_memory_ttl_hours.unwrap_or(24 * 30),
            importance_threshold: config.importance_threshold,
            max_memories_per_user: config.max_memories_per_user,
            compression_enabled: config.enable_compression,
            auto_summarize_sessions: true,
        };

        self.decay_engine.update_policy(decay_policy);
        self.config = config;
        
        Ok(())
    }
}

// C API for FFI integration with Node.js
// These functions provide a C-compatible interface for the Node.js bridge

/// Initialize MindCache with default config
#[no_mangle]
pub extern "C" fn mindcache_init() -> *mut MindCache {
    match MindCache::new() {
        Ok(cache) => Box::into_raw(Box::new(cache)),
        Err(_) => std::ptr::null_mut(),
    }
}

/// Initialize MindCache with config JSON string
#[no_mangle]
pub extern "C" fn mindcache_init_with_config(config_json: *const c_char) -> *mut MindCache {
    if config_json.is_null() {
        return std::ptr::null_mut();
    }

    let c_str = unsafe { CStr::from_ptr(config_json) };
    let config_str = match c_str.to_str() {
        Ok(s) => s,
        Err(_) => return std::ptr::null_mut(),
    };

    let config: MindCacheConfig = match serde_json::from_str(config_str) {
        Ok(c) => c,
        Err(_) => return std::ptr::null_mut(),
    };

    match MindCache::with_config(config) {
        Ok(cache) => Box::into_raw(Box::new(cache)),
        Err(_) => std::ptr::null_mut(),
    }
}

/// Save a memory item
#[no_mangle]
pub extern "C" fn mindcache_save(
    cache: *mut MindCache,
    user_id: *const c_char,
    session_id: *const c_char,
    content: *const c_char,
    metadata_json: *const c_char,
) -> *mut c_char {
    if cache.is_null() || user_id.is_null() || session_id.is_null() || content.is_null() {
        return std::ptr::null_mut();
    }

    let cache = unsafe { &mut *cache };
    let user_id = unsafe { CStr::from_ptr(user_id).to_str().unwrap_or("") };
    let session_id = unsafe { CStr::from_ptr(session_id).to_str().unwrap_or("") };
    let content = unsafe { CStr::from_ptr(content).to_str().unwrap_or("") };

    let metadata: Option<HashMap<String, String>> = if metadata_json.is_null() {
        None
    } else {
        let metadata_str = unsafe { CStr::from_ptr(metadata_json).to_str().unwrap_or("{}") };
        serde_json::from_str(metadata_str).ok()
    };

    match cache.save(user_id, session_id, content, metadata) {
        Ok(id) => {
            let c_string = CString::new(id).unwrap();
            c_string.into_raw()
        }
        Err(_) => std::ptr::null_mut(),
    }
}

/// Recall memories
#[no_mangle]
pub extern "C" fn mindcache_recall(
    cache: *mut MindCache,
    user_id: *const c_char,
    query: *const c_char,
    session_id: *const c_char,
    limit: i32,
) -> *mut c_char {
    if cache.is_null() || user_id.is_null() {
        return std::ptr::null_mut();
    }

    let cache = unsafe { &*cache };
    let user_id = unsafe { CStr::from_ptr(user_id).to_str().unwrap_or("") };
    let query = if query.is_null() {
        None
    } else {
        Some(unsafe { CStr::from_ptr(query).to_str().unwrap_or("") })
    };
    let session_id = if session_id.is_null() {
        None
    } else {
        Some(unsafe { CStr::from_ptr(session_id).to_str().unwrap_or("") })
    };
    let limit = if limit > 0 { Some(limit as usize) } else { None };

    match cache.recall(user_id, query, session_id, limit) {
        Ok(memories) => {
            match serde_json::to_string(&memories) {
                Ok(json) => {
                    let c_string = CString::new(json).unwrap();
                    c_string.into_raw()
                }
                Err(_) => std::ptr::null_mut(),
            }
        }
        Err(_) => std::ptr::null_mut(),
    }
}

/// Generate session summary
#[no_mangle]
pub extern "C" fn mindcache_summarize(
    cache: *mut MindCache,
    session_id: *const c_char,
) -> *mut c_char {
    if cache.is_null() || session_id.is_null() {
        return std::ptr::null_mut();
    }

    let cache = unsafe { &mut *cache };
    let session_id = unsafe { CStr::from_ptr(session_id).to_str().unwrap_or("") };

    match cache.summarize_session(session_id) {
        Ok(summary) => {
            match serde_json::to_string(&summary) {
                Ok(json) => {
                    let c_string = CString::new(json).unwrap();
                    c_string.into_raw()
                }
                Err(_) => std::ptr::null_mut(),
            }
        }
        Err(_) => std::ptr::null_mut(),
    }
}

/// Run decay process
#[no_mangle]
pub extern "C" fn mindcache_decay(cache: *mut MindCache) -> *mut c_char {
    if cache.is_null() {
        return std::ptr::null_mut();
    }

    let cache = unsafe { &mut *cache };

    match cache.decay() {
        Ok(stats) => {
            match serde_json::to_string(&stats) {
                Ok(json) => {
                    let c_string = CString::new(json).unwrap();
                    c_string.into_raw()
                }
                Err(_) => std::ptr::null_mut(),
            }
        }
        Err(_) => std::ptr::null_mut(),
    }
}

/// Get statistics
#[no_mangle]
pub extern "C" fn mindcache_get_stats(cache: *mut MindCache) -> *mut c_char {
    if cache.is_null() {
        return std::ptr::null_mut();
    }

    let cache = unsafe { &*cache };

    let stats = cache.get_stats();
    match serde_json::to_string(&stats) {
        Ok(json) => {
            let c_string = CString::new(json).unwrap();
            c_string.into_raw()
        }
        Err(_) => std::ptr::null_mut(),
    }
}

/// Free a C string returned by MindCache functions
#[no_mangle]
pub extern "C" fn mindcache_free_string(s: *mut c_char) {
    if !s.is_null() {
        unsafe {
            let _ = CString::from_raw(s);
        }
    }
}

/// Destroy MindCache instance
#[no_mangle]
pub extern "C" fn mindcache_destroy(cache: *mut MindCache) {
    if !cache.is_null() {
        unsafe {
            let _ = Box::from_raw(cache);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_mindcache_basic_operations() {
        // Create a temporary directory for testing
        let temp_dir = TempDir::new().expect("Should create temp dir");
        let config = MindCacheConfig {
            storage_path: temp_dir.path().to_str().unwrap().to_string(),
            auto_decay_enabled: false, // Disable for predictable testing
            decay_interval_hours: 24,
            default_memory_ttl_hours: Some(24),
            enable_compression: false, // Disable for simpler testing
            max_memories_per_user: 1000,
            importance_threshold: 0.3,
        };
        
        let mut cache = MindCache::with_config(config).unwrap();
        
        // Test save
        let memory_id = cache.save("test_user", "session_1", "I love trading gold", None).unwrap();
        assert!(!memory_id.is_empty());
        
        // Test recall
        let memories = cache.recall("test_user", Some("gold"), None, Some(10)).unwrap();
        assert_eq!(memories.len(), 1, "Should find the saved memory");
        assert_eq!(memories[0].content, "I love trading gold");
        
        // Test session creation
        let session_id = cache.create_session("test_user", Some("Trading Session")).unwrap();
        assert!(!session_id.is_empty());
        
        // Test saving to the created session
        let memory_id2 = cache.save("test_user", &session_id, "Another trading memory", None).unwrap();
        assert!(!memory_id2.is_empty());
        
        // Test recall all memories for user
        let all_memories = cache.recall("test_user", None, None, None).unwrap();
        assert_eq!(all_memories.len(), 2, "Should have both memories");
        
        // Temp directory will be automatically cleaned up when dropped
    }

    #[test]
    fn test_c_api_initialization() {
        let cache_ptr = mindcache_init();
        assert!(!cache_ptr.is_null(), "Default initialization should succeed");
        
        mindcache_destroy(cache_ptr);
        
        // Cleanup - but don't panic if it fails
        let _ = std::fs::remove_dir_all("./mindcache_data");
    }
}